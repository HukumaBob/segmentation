{% extends 'base.html' %}
{% block content %}
{% load static %}
{% load i18n %}
{% load custom_filters %}
{% get_current_language as LANGUAGE_CODE %}
<html lang="{{ LANGUAGE_CODE }}">

    <div class="container-fluid">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h2>{% trans "Edit Frame Sequence" %} - {{ sequence.features }}</h2>
            <button id="deleteFramesBtn" class="btn btn-danger">{% trans "Delete Selected Frames" %}</button>
        </div>
        <div class="row" id="frame-container">
            {% for frame in frames %}
                <div class="col-lg-3 col-md-4 col-sm-6 mb-4">
                    <div class="card frame-card" data-frame-id="{{ frame.id }}" data-frame-name="{{ frame.frame_file.name }}" data-frame-url="{{ frame.frame_file.url }}">
                        <input type="checkbox" class="delete-checkbox form-check-input" id="checkbox-{{ frame.id }}" value="{{ frame.id }}">
                        <div class="frame-wrapper" style="position: relative;">
                            <!-- Изображение кадра -->
                            <img src="{{ frame.frame_file.url }}" class="card-img-top frame-img" alt="{% trans 'Frame Image' %}" style="display: block;">
                            <!-- Canvas для масок в карточке -->
                            <canvas class="frame-mask-canvas" id="canvas-{{ frame.id }}" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></canvas>
                        </div>
                        <div class="card-body" style="background-color: {{ frame.sequences.features|generate_color }};">
                            <p class="card-text">{{ frame.frame_file.name }}</p>
                            <p class="card-text">{{ frame.sequences.features }}</p>
                        </div>
                    </div>
                </div>
            {% endfor %}
        </div>
    </div>


<!-- Модальное окно -->
<div id="frameModal" class="modal">
    <div class="modal-content">
        <span class="close-btn">&times;</span>
        
        <!-- Контейнер для изображения и canvas -->
        <div class="modal-image-wrapper">
            <img id="modalImage" src="" alt="Frame Image" class="modal-image">
            <canvas id="maskCanvas" class="mask-canvas"></canvas>
        </div>
        
        <!-- Блок с информацией и выбором параметров -->
        <div class="modal-info">
            <label for="modalFileName">{% trans "Sequence number" %}:</label>
            <h6 id="modalFileName"></h6>
            
            <!-- Селекторы для тегов и цвета -->
            <div class="d-flex align-items-center mb-3">
                <div class="me-3">
                    <label for="tagSelect">{% trans "Select Tag" %}:</label>
                    <select id="tagSelect" class="form-control">
                        {% for tag in tags %}
                            <option value="{{ tag.id }}">{{ tag.name }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div>
                    <label for="colorSelect">{% trans "Mask Color" %}:</label>
                    <input type="color" id="colorSelect" class="form-control" value="#00FF00">
                </div>
            </div>
            
            
            <!-- Блок для списка масок -->
            <div id="maskContainer" class="mask-container">
                <h6>{% trans "Available Masks" %}</h6>
                <div id="maskList" class="mask-list">
                    <!-- Список масок будет динамически добавляться сюда -->
                </div>
            </div>

            <div>
                <button id="extrapolateBtn" class="btn btn-primary mt-3">{% trans "Create mask for all frames" %}</button>
            </div>
        </div>
    </div>
</div>


<style>
    /* Тёмная тема */
    body.dark-mode .modal-content {
        background-color: #333;
        color: #fff;
    }
    
    body.dark-mode .modal-info h5,
    body.dark-mode .modal-info label,
    body.dark-mode .modal-info h6 {
        color: #fff;
    }

    /* Общий стиль для карточек */
    .frame-card {
        position: relative;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        height: 100%;
    }
    
    .frame-wrapper {
        overflow: hidden;
        flex-grow: 1;
    }
    
    .frame-card img {
        width: 100%;
        height: auto;
        object-fit: cover;
    }
    
    .delete-checkbox {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 105;
        transform: scale(1.5);
        cursor: pointer;
    }

    /* Стили для модального окна */
    .modal {
        display: none;
        position: fixed;
        z-index: 200;
        inset: 0; /* Альтернатива: top: 0; left: 0; width: 100%; height: 100%; */
        background-color: rgba(0, 0, 0, 0.6);
    }
    
    .modal-content {
        position: relative;
        margin: 5% auto;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: row;
        align-items: flex-start;
        padding: 10px;
        background: var(--bs-body-bg, #fff); /* Тема по умолчанию */
        color: var(--bs-body-color, #000);
        border-radius: 0.5rem; /* Округленные углы для лучшего дизайна */
    }
    
    .modal-image-wrapper {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
    }
    
    .modal-image, .mask-canvas {
        max-width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
    }
    
    .modal-info {
        width: 40%;
        padding-left: 15px;
        display: flex;
        flex-direction: column;
        align-items: left;
        justify-content: flex-start;
    }
    
    .close-btn {
        position: absolute;
        top: 15px;
        right: 20px;
        font-size: 30px;
        color: #aaa;
        cursor: pointer;
    }
    
    .close-btn:hover, .close-btn:focus {
        color: #000;
    }
    
    /* Стили для контейнера с масками */
    .mask-container {
        margin-top: 20px;
        width: 100%;
        padding-left: 5px;
    }
    
    .mask-list {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        padding: 10px;
        max-height: 200px;
        overflow-y: auto; /* Прокрутка для длинного списка */
    }
    
    .mask-item {
        margin: 5px 0;
        display: flex;
        align-items: center;
    }
    
    .mask-item input {
        margin-right: 5px;
    }
</style>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const currentLang = document.documentElement.lang || 'en';
        const frameCards = document.querySelectorAll('.frame-card');
        const modal = document.getElementById('frameModal');
        const modalImage = document.getElementById('modalImage');
        const modalFileName = document.getElementById('modalFileName');
        const closeButton = document.querySelector('.close-btn');
        const maskCanvas = document.getElementById('maskCanvas');
        const tagSelect = document.getElementById('tagSelect');  // Получаем элемент select для тегов
        const colorSelect = document.getElementById('colorSelect');  // Получаем элемент выбора цвета
        const ctx = maskCanvas.getContext('2d');
        const extrapolateBtn = document.getElementById('extrapolateBtn');
        const maskListContainer = document.getElementById('maskList');  // Контейнер для списка масок
        const deleteFramesBtn = document.getElementById('deleteFramesBtn'); // Найдем кнопку Delete
        let activeFrameId = null;

    deleteFramesBtn.addEventListener('click', () => {
        // Получаем все отмеченные чекбоксы
        const selectedFrames = Array.from(
            document.querySelectorAll('.delete-checkbox:checked')
        ).map((checkbox) => checkbox.value); // Извлекаем значения (ID кадров)

        if (selectedFrames.length === 0) {
            alert('Please select at least one frame to delete.');
            return;
        }

        if (confirm('Are you sure you want to delete the selected frames?')) {
            fetch(`/${ currentLang }/delete_frames/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCSRFToken(), // Получаем CSRF-токен
                },
                body: JSON.stringify({ frame_ids: selectedFrames }), // Отправляем список ID кадров
            })
                .then((response) => {
                    if (!response.ok) {
                        throw new Error(`Server responded with status: ${response.status}`);
                    }
                    return response.json();
                })
                .then((data) => {
                    if (data.status === 'success') {
                        alert('Selected frames deleted successfully.');
                        // Удаляем карточки кадров из интерфейса
                        removeDeletedFrames(selectedFrames);
                    } else {
                        console.error('Error deleting frames:', data.error);
                        alert('Error occurred while deleting frames.');
                    }
                })
                .catch((error) => console.error('Error:', error));
        }
    });

    // Функция для получения CSRF-токена из cookies
    function getCSRFToken() {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.startsWith('csrftoken=')) {
                    cookieValue = decodeURIComponent(cookie.substring('csrftoken='.length));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // Функция для удаления карточек кадров из контейнера
    function removeDeletedFrames(frameIds) {
        frameIds.forEach((frameId) => {
            const frameCard = document.querySelector(`.frame-card[data-frame-id="${frameId}"]`);
            if (frameCard) frameCard.remove(); // Удаляем карточку из DOM
        });
    }

            // Массив для хранения всех отмеченных точек
            let points = [];

            // Переменные для хранения размеров canvas и изображения на сервере
            let canvasWidth, canvasHeight, imageWidth, imageHeight;

            // Отключаем стандартное контекстное меню
            maskCanvas.addEventListener('contextmenu', (e) => e.preventDefault());

// Функция для удаления конкретной маски
function deleteMask(maskId) {
    console.log(`Deleting mask with ID: ${maskId}`);
    fetch(`/delete_mask/?mask_id=${maskId}`, { method: 'DELETE' })
        .then(response => {
            if (response.ok) {
                document.querySelector(`input[data-mask-id="${maskId}"]`).closest('.mask-item').remove();
            }
        })
        .catch(error => console.error('Error deleting mask:', error));
}

// Функция для удаления текущей и всех последующих масок
function deleteFollowingMasks(startIndex, masks) {
    console.log(`Deleting masks from index ${startIndex} onwards`);

    const masksToDelete = masks.slice(startIndex);
    const deletePromises = masksToDelete.map(mask =>
        fetch(`/delete_mask/?mask_id=${mask.id}`, { method: 'DELETE' })
    );

    Promise.all(deletePromises)
        .then(() => {
            masksToDelete.forEach(mask => {
                const maskItem = document.querySelector(`input[data-mask-id="${mask.id}"]`).closest('.mask-item');
                if (maskItem) maskItem.remove();
            });
        })
        .catch(error => console.error('Error deleting masks:', error));
}            
            
// Открытие модального окна
function showModal(frameId, frameUrl, frameName) {
    modal.style.display = 'block';
    modalImage.src = frameUrl;
    // Update the modal's filename text content
    modalFileName.textContent = frameName.split('/').pop().split('.')[0];
    activeFrameId = frameId;
    maskListContainer.innerHTML = '';  // Очищаем контейнер списка масок
    
    setTimeout(() => {
        canvasWidth = modalImage.clientWidth;
        canvasHeight = modalImage.clientHeight;
        maskCanvas.width = canvasWidth;
        maskCanvas.height = canvasHeight;
        ctx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
        points = [];  // Очищаем точки при открытии нового кадра
        console.log(`Canvas size set: ${maskCanvas.width}x${maskCanvas.height}`);

        // Загрузка размеров изображения на сервере
        fetch(`/get_image_size/?frame_id=${frameId}`)
            .then(response => response.json())
            .then(data => {
                imageWidth = data.width;
                imageHeight = data.height;
                console.log(`Image size on server: ${imageWidth}x${imageHeight}`);

                // Загрузка всех масок для текущего кадра
                fetch(`/get_masks/?frame_id=${frameId}`)
                    .then(response => response.json())
                    .then(masks => {
                        console.log('Masks loaded:', masks);
                        // Добавляем маски в список выбора
                        masks.forEach(mask => {
                            const maskItem = document.createElement('div');
                            maskItem.classList.add('mask-item');
                            
                            // Чекбокс для включения/выключения маски
                            const maskCheckbox = document.createElement('input');
                            maskCheckbox.type = 'checkbox';
                            maskCheckbox.dataset.maskId = mask.id;
                            maskCheckbox.dataset.maskUrl = mask.mask_file;  // Сохраняем URL маски
                            maskCheckbox.checked = true;  // По умолчанию все маски включены
                            maskCheckbox.addEventListener('change', () => toggleMask(mask.id, mask.mask_file));
                            
                            // Элемент для отображения названия маски
                            const maskLabel = document.createElement('label');
                            maskLabel.textContent = `Mask ID: ${mask.id} (Tag: ${mask.tag})`;
                            // Кнопка удаления только текущей маски
                            const deleteButton = document.createElement('button');
                            deleteButton.classList.add('btn', 'btn-sm', 'btn-danger', 'ms-2');
                            deleteButton.textContent = 'Delete';
                            deleteButton.addEventListener('click', () =>
                                deleteMask(mask.id)
                            );

                            // Кнопка удаления текущей и всех последующих масок
                            const deleteAllButton = document.createElement('button');
                            deleteAllButton.classList.add('btn', 'btn-sm', 'btn-warning', 'ms-2');
                            deleteAllButton.textContent = 'Delete All Following';
                            deleteAllButton.addEventListener('click', () =>
                                deleteFollowingMasks(index, masks)
                            );

                            // Добавляем элементы в DOM
                            maskItem.appendChild(maskCheckbox);
                            maskItem.appendChild(maskLabel);
                            maskItem.appendChild(deleteButton);
                            maskItem.appendChild(deleteAllButton);
                            maskListContainer.appendChild(maskItem);
            
                            // Отрисовываем маску на canvas
                            drawMask(mask.mask_file);
                        });
                    });
            });
    }, 100);
}
        
        
        extrapolateBtn.addEventListener('click', () => {
            const transformedPoints = transformPoints(points, canvasWidth, canvasHeight, imageWidth, imageHeight);
            if (activeFrameId) {
                // Выводим текущий активный ID кадра перед отправкой запроса
                console.log(`Extrapolation started for frame ID: ${activeFrameId}`);
    
                // Отправляем запрос на экстраполяцию с указанием текущего кадра
                fetch(`/${currentLang }/extrapolate_masks/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': '{{ csrf_token }}'
                    },
                    body: JSON.stringify({
                        sequence_id: {{ sequence.id }},
                        tag_id: tagSelect.value,
                        mask_color: colorSelect.value,
                        current_frame_id: activeFrameId,
                        points: transformedPoints,
                    })
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Server responded with status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Extrapolation completed:', data);
                    alert('Extrapolation completed successfully!');
                })
                .catch(error => {
                    console.error('Error during extrapolation:', error);
                    alert('Error occurred during extrapolation.');
                });
            } else {
                console.error('No active frame selected for extrapolation');
            }
        });
        // Закрытие модального окна
        function closeModal() {
            modal.style.display = 'none';
            modalImage.src = '';
            modalFileName.textContent = '';
            ctx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
            activeFrameId = null;
            points = [];  // Очищаем все точки при закрытии
        }

        // Функция отрисовки всех точек на canvas с метками координат
        function drawPoints() {
            points.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);  // Радиус 5 пикселей
                ctx.fillStyle = point.sign === '+' ? 'green' : 'red';  // Цвет точки в зависимости от знака
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Отрисовываем текстовые координаты для визуализации
                ctx.font = '12px Arial';
                ctx.fillStyle = 'black';
                ctx.fillText(`(${point.x}, ${point.y})`, point.x + 5, point.y - 5);
            });
        }


        function transformPoints(points, canvasWidth, canvasHeight, imageWidth, imageHeight) {
            // Определяем точные коэффициенты масштабирования
            const scaleX = imageWidth / canvasWidth;
            const scaleY = imageHeight / canvasHeight;
        
            return points.map(point => {
                // Вычисляем исходные координаты на основе коэффициентов масштаба
                const transformedX = point.x * scaleX;
                const transformedY = point.y * scaleY;
        
                // Округление до ближайшего целого для точного позиционирования
                return {
                    x: Math.round(transformedX),
                    y: Math.round(transformedY),
                    sign: point.sign
                };
            });
        }
        
        

        // Обработчик клика по canvas
        maskCanvas.addEventListener('mousedown', (event) => {
            event.preventDefault();

            const rect = maskCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;  // Координаты клика по canvas
            const y = event.clientY - rect.top;

            const canvasX = Math.floor(x);
            const canvasY = Math.floor(y);

            console.log(`Canvas click: X=${canvasX}, Y=${canvasY}`);

            // Обработка добавления или удаления точки
            if (event.button === 2) {
                points.push({ x: canvasX, y: canvasY, sign: '-' });
            } else if (event.ctrlKey && event.button === 0) {
                const removeIndex = points.findIndex(point => Math.hypot(point.x - canvasX, point.y - canvasY) < 10);
                if (removeIndex !== -1) {
                    points.splice(removeIndex, 1);
                }
            } else if (event.button === 0) {
                points.push({ x: canvasX, y: canvasY, sign: '+' });
            }

            drawPoints();
            sendMaskData();  // Автоматическое обновление маски
        });

        // Функция отправки данных на сервер и обновления маски на canvas
        function sendMaskData() {
            if (activeFrameId && points.length > 0) {
                // Пересчет координат перед отправкой
                const transformedPoints = transformPoints(points, canvasWidth, canvasHeight, imageWidth, imageHeight);
                console.log(`Transformed points: ${JSON.stringify(transformedPoints)}`);
                
                // Получаем текущий выбранный тег
                const selectedTagId = tagSelect.value;
                
                // Получаем выбранный цвет маски из input
                const selectedMaskColor = colorSelect.value;

                fetch(`/${currentLang}/generate_mask/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': '{{ csrf_token }}'
                    },
                    body: JSON.stringify({
                        sequence_id: {{ sequence.id }},
                        frame_id: activeFrameId,
                        points: transformedPoints,
                        tag_id: selectedTagId,  // Передаем выбранный тег
                        mask_color: selectedMaskColor  // Передаем выбранный цвет маски
                    })
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Server responded with status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Server response:', data);
                    
                    if (data.mask_url) {
                        const img = new Image();
                        img.src = `${data.mask_url}?timestamp=${new Date().getTime()}`;
                        img.onload = () => {
                            ctx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
                            ctx.drawImage(img, 0, 0, maskCanvas.width, maskCanvas.height);
                            drawPoints();  // Отрисовка точек поверх маски
                        };
                    }
                })
                .catch(error => console.error('Error during fetch:', error));
            }
        }
        
    // Функция для отображения выбранной маски на canvas
    function drawMask(maskUrl) {
        const img = new Image();
        console.log(`Drawing mask from URL: ${maskUrl}`);
        img.src = `${maskUrl}?timestamp=${new Date().getTime()}`;
        img.onload = () => {
            ctx.drawImage(img, 0, 0, maskCanvas.width, maskCanvas.height);
        };
    }

    // Функция для включения/выключения масок
    function toggleMask(maskId, maskUrl) {
        const maskCheckbox = document.querySelector(`[data-mask-id="${maskId}"]`);
        if (maskCheckbox.checked) {

            drawMask(maskUrl);  // Включение маски
        } else {
            // Удаление маски из canvas
            ctx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);  // Очищаем все
            // Перерисовываем оставшиеся включенные маски
            document.querySelectorAll('.mask-item input:checked').forEach(checkbox => {
                const activeMaskId = checkbox.dataset.maskId;
                const activeMaskUrl = checkbox.dataset.maskUrl;
                drawMask(activeMaskUrl);
            });
        }
    }

    // Загружаем маски для всех кадров при первой загрузке страницы
    frameCards.forEach(card => {
        const frameId = card.dataset.frameId;
        const canvas = document.getElementById(`canvas-${frameId}`);
        const ctx = canvas.getContext('2d');

        // Загружаем маски для этого кадра
        loadMasks(frameId, ctx, canvas);

        // Устанавливаем обработчик для открытия модального окна
        card.addEventListener('click', (event) => {
            if (event.target.classList.contains('delete-checkbox')) return;

            const frameUrl = card.dataset.frameUrl;
            const frameName = card.dataset.frameName;

            // Показ модального окна с кадром
            showModal(frameId, frameUrl, frameName);

            event.stopPropagation();
        });
    });

    // Функция для загрузки масок для указанного кадра
    function loadMasks(frameId, ctx, canvas) {
        fetch(`/get_masks/?frame_id=${frameId}`)
            .then(response => response.json())
            .then(masks => {
                {% comment %} ctx.clearRect(0, 0, canvas.width, canvas.height); // Очищаем canvas {% endcomment %}
                masks.forEach(mask => {
                    drawMaskOnCanvas(ctx, mask.mask_file, canvas);
                });
            })
            .catch(error => console.error(`Error loading masks for frame ${frameId}:`, error));
    }

    // Функция отрисовки маски на canvas
    function drawMaskOnCanvas(ctx, maskUrl, canvas) {
        const img = new Image();
        img.src = `${maskUrl}?timestamp=${new Date().getTime()}`; // Кэширование
        img.onload = () => {
            {% comment %} ctx.clearRect(0, 0, canvas.width, canvas.height); // Очищаем canvas перед отрисовкой {% endcomment %}
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height); // Отрисовываем маску
        };
    }

        closeButton.addEventListener('click', closeModal);
        window.addEventListener('click', (event) => {
            if (event.target === modal) {
                closeModal();
            }
        });
    });
</script>

{% endblock %}
