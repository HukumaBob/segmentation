{% extends 'base.html' %}
{% block content %}
{% load static %}
{% load i18n %}
<div class="container-fluid">
    <h2>{% trans "Edit Frame Sequence" %} - {{ sequence.features }}</h2>
    <div class="row" id="frame-container">
        {% for frame in frames %}
            <div class="col-3 mb-4">
                <div class="card frame-card" data-frame-id="{{ frame.id }}" data-frame-name="{{ frame.frame_file.name }}" data-frame-url="{{ frame.frame_file.url }}">
                    <input type="checkbox" class="delete-checkbox" id="checkbox-{{ frame.id }}" value="{{ frame.id }}">
                    <div class="frame-wrapper">
                        <img src="{{ frame.frame_file.url }}" class="card-img-top frame-img" alt="{% trans 'Frame Image' %}">
                    </div>
                    <div class="card-body">
                        <p class="card-text">{{ frame.frame_file.name }}</p>
                    </div>
                </div>
            </div>
        {% endfor %}
    </div>
</div>

<!-- Модальное окно -->
<div id="frameModal" class="modal">
    <div class="modal-content">
        <span class="close-btn">&times;</span>
        <div class="modal-image-wrapper">
            <img id="modalImage" src="" alt="Frame Image" class="modal-image">
            <canvas id="maskCanvas" class="mask-canvas"></canvas>
        </div>
        <div class="modal-info">
            <h5 id="modalFileName"></h5>
            <button id="saveButton" class="btn btn-primary">{% trans 'Save Mask' %}</button>
            <button id="deleteButton" class="btn btn-danger">{% trans 'Delete' %}</button>
        </div>
    </div>
</div>

<style>
    .frame-card { position: relative; cursor: pointer; display: flex; flex-direction: column; height: 100%; }
    .frame-wrapper { overflow: hidden; flex-grow: 1; }
    .frame-card img { width: 100%; height: 100%; object-fit: cover; }
    .modal { display: none; position: fixed; z-index: 200; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); }
    .modal-content { position: relative; margin: 5% auto; width: 75%; height: 75%; background: #ffffff; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 10px; }
    .modal-image-wrapper { width: 100%; height: 85%; display: flex; justify-content: center; align-items: center; background-color: #f7f7f7; position: relative; }
    .modal-image { width: 100%; height: 100%; object-fit: contain; position: absolute; top: 0; left: 0; z-index: 1; }
    .mask-canvas { position: absolute; top: 0; left: 0; z-index: 2; width: 100%; height: 100%; }
    .modal-info { text-align: center; margin-top: 10px; }
    .close-btn { position: absolute; top: 15px; right: 20px; font-size: 30px; color: #aaa; cursor: pointer; }
    .close-btn:hover, .close-btn:focus { color: #000; }
    .delete-checkbox { position: absolute; top: 10px; left: 10px; z-index: 105; transform: scale(1.5); cursor: pointer; }
</style>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const frameCards = document.querySelectorAll('.frame-card');
        const modal = document.getElementById('frameModal');
        const modalImage = document.getElementById('modalImage');
        const modalFileName = document.getElementById('modalFileName');
        const deleteButton = document.getElementById('deleteButton');
        const saveButton = document.getElementById('saveButton');
        const closeButton = document.querySelector('.close-btn');
        const maskCanvas = document.getElementById('maskCanvas');
        const ctx = maskCanvas.getContext('2d');
        let activeFrameId = null;

        // Массив для хранения всех отмеченных точек
        let points = [];

        // Переменные для хранения размеров canvas и изображения на сервере
        let canvasWidth, canvasHeight, imageWidth, imageHeight;

        // Отключаем стандартное контекстное меню
        maskCanvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // Открытие модального окна
        function showModal(frameId, frameUrl, frameName) {
            modal.style.display = 'block';
            modalImage.src = frameUrl;
            modalFileName.textContent = frameName;
            activeFrameId = frameId;

            // Устанавливаем размеры canvas в соответствии с изображением
            setTimeout(() => {
                canvasWidth = modalImage.clientWidth;
                canvasHeight = modalImage.clientHeight;
                maskCanvas.width = canvasWidth;
                maskCanvas.height = canvasHeight;
                ctx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
                points = [];  // Очищаем точки при открытии нового кадра
                console.log(`Canvas size set: ${maskCanvas.width}x${maskCanvas.height}`);

                // Загрузка размеров изображения на сервере
                fetch(`/get_image_size/?frame_id=${frameId}`)
                    .then(response => response.json())
                    .then(data => {
                        imageWidth = data.width;
                        imageHeight = data.height;
                        console.log(`Image size on server: ${imageWidth}x${imageHeight}`);
                    });
            }, 100);
        }

        // Закрытие модального окна
        function closeModal() {
            modal.style.display = 'none';
            modalImage.src = '';
            modalFileName.textContent = '';
            ctx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
            activeFrameId = null;
            points = [];  // Очищаем все точки при закрытии
        }

        // Отрисовка всех точек на canvas
        function drawPoints() {
            ctx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);  // Очистка canvas
            points.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);  // Радиус 5 пикселей
                ctx.fillStyle = point.sign === '+' ? 'green' : 'red';  // Цвет точки в зависимости от знака
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1.5;
                ctx.stroke();
            });
        }

        // Обработчик клика по canvas
        maskCanvas.addEventListener('mousedown', (event) => {
            event.preventDefault();

            const rect = maskCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;  // Координаты клика по canvas
            const y = event.clientY - rect.top;

            const canvasX = Math.floor(x);
            const canvasY = Math.floor(y);

            console.log(`Canvas click: X=${canvasX}, Y=${canvasY}`);

            // Обработка добавления или удаления точки
            if (event.button === 2) {
                points.push({ x: canvasX, y: canvasY, sign: '-' });
            } else if (event.ctrlKey && event.button === 0) {
                const removeIndex = points.findIndex(point => Math.hypot(point.x - canvasX, point.y - canvasY) < 10);
                if (removeIndex !== -1) {
                    points.splice(removeIndex, 1);
                }
            } else if (event.button === 0) {
                points.push({ x: canvasX, y: canvasY, sign: '+' });
            }

            drawPoints();
        });

        // Пересчет координат относительно размера изображения на сервере
        function transformPoints(points, canvasWidth, canvasHeight, imageWidth, imageHeight) {
            return points.map(point => {
                return {
                    x: Math.round(point.x * imageWidth / canvasWidth),
                    y: Math.round(point.y * imageHeight / canvasHeight),
                    sign: point.sign
                };
            });
        }

        // Обработчик нажатия на кнопку Save Mask
        saveButton.addEventListener('click', () => {
            sendMaskData();
        });

        // Функция отправки данных на сервер
        function sendMaskData() {
            if (activeFrameId && points.length > 0) {
                // Пересчет координат перед отправкой
                const transformedPoints = transformPoints(points, canvasWidth, canvasHeight, imageWidth, imageHeight);
                console.log(`Transformed points: ${JSON.stringify(transformedPoints)}`);

                fetch(`/en/generate_mask/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': '{{ csrf_token }}'
                    },
                    body: JSON.stringify({
                        frame_id: activeFrameId,
                        points: transformedPoints,
                        tag_id: 1
                    })
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Server responded with status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Server response:', data);
                    if (data.mask_url) {
                        const img = new Image();
                        img.src = data.mask_url;
                        img.onload = () => {
                            ctx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
                            ctx.drawImage(img, 0, 0, maskCanvas.width, maskCanvas.height);
                            drawPoints();
                        };
                    }
                })
                .catch(error => console.error('Error during fetch:', error));
            }
        }

        frameCards.forEach(card => {
            card.addEventListener('click', (event) => {
                if (event.target.classList.contains('delete-checkbox')) return;

                const frameId = card.dataset.frameId;
                const frameUrl = card.dataset.frameUrl;
                const frameName = card.dataset.frameName;

                showModal(frameId, frameUrl, frameName);
                event.stopPropagation();
            });
        });

        closeButton.addEventListener('click', closeModal);
        window.addEventListener('click', (event) => {
            if (event.target === modal) {
                closeModal();
            }
        });
    });
</script>
{% endblock %}
